\chapter{Evaluation}
\label{chap:evaluation} % Hinzugefügt, falls andere Kapitel darauf verweisen

Dieses Kapitel evaluiert das entwickelte RTReconstruct-System hinsichtlich seiner 
Echtzeitfähigkeit, Modularität und Rekonstruktionsqualität. Zunächst werden die 
Evaluationsziele definiert und die Testumgebung beschrieben. Anschließend erfolgt 
die Darstellung der gemessenen Performance-Metriken sowie der Rekonstruktionsqualität 
der integrierten Modelle. Das Kapitel schließt mit einer Diskussion der Ergebnisse 
im Kontext der definierten Anforderungen.

\section{Evaluationsziele}
\label{sec:eval_ziele}

Die Evaluation verfolgt drei zentrale Ziele, die direkt aus der in Abschnitt formulierten Forschungsfrage abgeleitet sind:

\begin{enumerate}
    \item \textbf{Funktionale Validierung}: Nachweis, dass die modulare Architektur 
    die definierten funktionalen Anforderungen erfüllt. Insbesondere wird geprüft, 
    ob verschiedene Rekonstruktionsmodelle parallel betrieben werden können und ob 
    die End-to-End Kommunikation zwischen VR-Frontend und Backend stabil funktioniert.
    
    \item \textbf{Echtzeitfähigkeit}: Bewertung, ob das System die für VR-Anwendungen 
    erforderlichen Performance-Anforderungen erfüllt. Dabei werden Latenz, Durchsatz 
    und Ressourcenauslastung als kritische Metriken untersucht.
    
    \item \textbf{Rekonstruktionsqualität}: Qualitative und -- soweit möglich -- 
    quantitative Bewertung der von den integrierten Modellen erzeugten 
    3D-Rekonstruktionen unter identischen Bedingungen.
\end{enumerate}

\section{Evaluationsmethodik}
Die Evaluationsmethodik beschreibt die Testumgebung, die verwendeten Testszenarien und die Messmethoden, die zur Erreichung der Evaluationsziele eingesetzt wurden. 

\subsection{Test- und Evaluationsumgebung}
\label{sec:testumgebung}

Um die \textbf{Reproduzierbarkeit} der Performance-Messungen und die \textbf{Vergleichbarkeit} der erzielten Ergebnisse zu gewährleisten, wurde die gesamte Evaluation in einer dedizierten und \textbf{kontrollierten Hard- und Software-Umgebung} durchgeführt. Die zentralen Komponenten und Spezifikationen dieser Umgebung sind in Tabelle~\ref{tab:hardware_and_software} zusammengefasst.

\begin{table}[H]
    \centering
    \label{tab:hardware_and_software}
    \caption{Spezifikationen der Hard- und Software-Umgebung}
    \begin{tabularx}{\textwidth}{l X}
        \toprule
        \textbf{Kategorie} & \textbf{Details und Spezifikationen} \\
        \midrule
        \multicolumn{2}{l}{\textbf{Hardware-Umgebung (Backend/Server)}} \\
        \midrule
        Backend-Server CPU & AMD Ryzen 9 5900X (12 Kerne, 24 Threads) \\
        GPU & NVIDIA GeForce GTX 1070 Ti, 8 GB VRAM \\
        VR-System (Frontend) & Meta Quest 3 \\
        Netzwerk & WiFi 6 Heimnetzwerk \\
        \midrule
        \multicolumn{2}{l}{\textbf{Software-Umgebung und Frameworks}} \\
        \midrule
        Betriebssystem & Ubuntu 22.04 LTS (Host) \\
        Containerisierung & Docker (\textit{[Version einfügen, z.B. 24.0.7]}) \\
        GPU-Unterstützung & NVIDIA Container Toolkit \\
        VR-Frontend & Unity (\textit{2022.3 LTS}) \\
        \bottomrule
    \end{tabularx}
\end{table}

\noindent
Alle Messungen erfolgten unter \textbf{kontrollierten Bedingungen}. Es wurde strikt darauf geachtet, dass während der Performance-Tests \textbf{keine weiteren rechenintensiven Hintergrundprozesse} liefen, um Verzerrungen zu minimieren.

\subsection{Testszenarien und Datensätze}

Für die Evaluation wurden fünf Testszenen mit unterschiedlichen Komplexitätsstufen 
konzipiert: drei virtuelle Szenen mit verfügbarem Ground-Truth zur quantitativen 
Bewertung sowie zwei reale Szenen aus einem typischen Alltagsumfeld zur Validierung der
Praxistauglichkeit. Eine kurze Übersicht über alle Testszenen findet sich in Tabelle~\ref{tab:test_scenes_overview}.

\begin{table}[H]
    \centering
    \label{tab:test_scenes_overview}
    \begin{tabularx}{\textwidth}{lcclX}
        \toprule
        \textbf{Szene} & \textbf{Größe (m)} & \textbf{Fragments} & \textbf{Frames} & \textbf{Merkmale} \\
        \midrule
        \multicolumn{5}{l}{\textbf{Virtuelle Szenen}} \\
        V1 -- Primitive & $5\times 5\times 5$ & 24 & 216 & Geometrische Grundformen, unifarbige Oberflächen \\
        V2 -- Schlafzimmer & $6\times 5\times 3$ & 44 & 396 & moderate Komplexität, Okklusionen \\
        V3 -- Mehrzweckraum & $10\times 5\times 3$ & 58 & 522 & Hohe Dichte, komplexe Geometrie \\
        \midrule
        \multicolumn{5}{l}{\textbf{Reale Szenen}} \\
        R1 & $4\times 4\times 3$ & [150] & [40] & \textit{Schlafzimmer}, Details, Schrägen, Okklusionen \\
        R2 & $6\times 5\times 3$ & [200] & [50] & \textit{Wohnzimmer}, Glas, Reflexionen, große Flächen \\
        \bottomrule
    \end{tabularx}
    \caption{Übersicht und Klassifikation der Testszenen}
\end{table}

\subsubsection{Virtuelle Szenen}

Die drei virtuellen Szenen wurden in Unity erstellt und ermöglichen durch verfügbare \textit{Ground-Truth-Meshes} eine quantitative Evaluation mittels F-Score. Die Szenen folgen einer progressiven Komplexitätssteigerung, um verschiedene Aspekte der Rekonstruktionsverfahren isoliert zu testen. Abbildung~\ref{fig:virtual_scenes} zeigt eine Übersicht aller drei Szenen.

\paragraph{Szene V1 -- Geometrische Primitive}
Szene V1 dient als Baseline-Test und enthält ausschließlich einfache geometrische Primitive (Quader, Pyramide, Zylinder, Kapsel) in einem hexagonalen Raum mit farbigen Wänden. Die unifarbigen, matten Oberflächen ohne Texturen ermöglichen die isolierte Bewertung fundamentaler Rekonstruktionsfähigkeiten: scharfe Kanten, gekrümmte Oberflächen und feature-arme Flächen.

\paragraph{Szene V2 -- Möbliertes Schlafzimmer}
Szene V2 repräsentiert einen möblierten Innenraum mittlerer Komplexität mit Doppelbett, Sessel, Sideboard, Wandbildern und Stehlampe. Diese Szene testet die Rekonstruktion komplexer Möbelgeometrie, das Verhalten bei Okklusionen, die Texturverarbeitung sowie die Detailerfassung kleiner Dekorationsobjekte.

\paragraph{Szene V3 -- Komplexer Mehrzweckraum}
Szene V3 stellt einen Stresstest für Skalierbarkeit und Detailtreue dar und simuliert einen multifunktionalen Raum mit Schlaf-, Wohn- und Arbeitsbereich. Die hohe Objektdichte mit zwei Betten, Esstisch, Stühlen und diversen Kleinobjekten erzeugt multiple Okklusionsebenen. Erwartet werden längere Inferenzzeiten, höhere GPU-Auslastung und potenzielle Artefakte bei geometrisch komplexen Strukturen und teilweise verdeckten Bereichen.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.32\textwidth]{images/room00.png}
    \includegraphics[width=0.32\textwidth]{images/room01.png}
    \includegraphics[width=0.32\textwidth]{images/Room02.png}
    \caption{Übersicht der drei virtuellen Testszenen: V1 (Geometrische Primitive), V2 (Möbliertes Schlafzimmer), V3 (Komplexer Mehrzweckraum)}
    \label{fig:virtual_scenes}
\end{figure}

\subsubsection{Reale Szenen}

Die beiden realen Szenen wurden im Va.Si.Li-Lab aufgenommen und validieren die Praxistauglichkeit des Systems unter realen Bedingungen mit natürlichen Störfaktoren.

\paragraph{Szene R1 -- Schlafzimmer}

Szene R1 simuliert ein kleines, dicht möbliertes, privates Umfeld. Details, Schrägen, Okklusionen. Der Testfokus liegt auf der Robustheit gegenüber Textiloberflächen und diffuser Beleuchtung, welche die Rekonstruktion feiner Details und das Verhalten bei Oberflächenhomogenität überprüfen.

\paragraph{Szene R2 -- Wohnzimmer}

Szene R2 simuliert ein großes Wohnzimmer mit offener Gestaltung. Große Flächen, Glas, Reflexionen. Die Szene dient als Skalierbarkeits- und Materialstresstest. Im Fokus stehen die Handhabung großer, glänzender Flächen und Fenster, die Reflexionen verursachen, sowie repetitive Dekorelemente, welche die globale Konsistenz und Anfälligkeit für visuellen Drift testen.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.49\textwidth]{images/room01.png}
    \includegraphics[width=0.49\textwidth]{images/room01.png}
    \caption{Übersicht der beiden realen Testszenen: R1 (Schlafzimmer), R2 (Wohnzimmer)}
    \label{fig:real_scenes}
\end{figure}

\subsection{Messverfahren und Metriken}

\subsubsection{Performance-Metriken}

\paragraph{Latenz}
Die End-to-End-Latenz misst die Zeitspanne zwischen dem Versenden eines Fragments 
durch das Unity-Frontend und der Visualisierung der aktualisierten Rekonstruktion 
im VR-Headset. Sie setzt sich aus folgenden Komponenten zusammen:
\begin{align}
    L_{\text{total}} = L_{\text{network}} + L_{\text{inference}} + L_{\text{render}}
\end{align}
wobei $L_{\text{network}}$ die Netzwerklatenz (Upload des Fragments und Download 
der Rekonstruktion), $L_{\text{inference}}$ die Modell-Inferenzzeit im Backend 
(GPU-Verarbeitung) und $L_{\text{render}}$ die Rendering-Zeit im Unity-Client 
(GLB-Import und Mesh-Visualisierung) bezeichnet.

\medskip
\noindent
Die Netzwerklatenz $L_{\text{network}} = L_{\text{upload}} + L_{\text{download}}$ 
wird nicht direkt durch Zeitstempel gemessen, sondern aus den erfassten Datenvolumina 
und der verfügbaren Netzwerkbandbreite berechnet: $L_{\text{upload}} = S_{\text{fragment}} / B_{\text{upload}}$ 
bzw. $L_{\text{download}} = S_{\text{result}} / B_{\text{download}}$. Hierbei 
bezeichnet $S_{\text{fragment}}$ die Fragmentgröße (Upload-Volumen pro Fragment) 
und $S_{\text{result}}$ die Resultgröße (Download-Volumen der Rekonstruktion). 
Diese Methodik ermöglicht eine infrastrukturunabhängige Bewertung der Dateneffizienz.

\medskip
\noindent
Die Messung der übrigen Latenzkomponenten erfolgte durch präzise Zeitstempel an 
den jeweiligen Übergangspunkten der Pipeline.

\paragraph{Durchsatz}
Der Durchsatz quantifiziert, wie viele Fragmente pro Sekunde durch das System 
verarbeitet werden können. Ein höherer Durchsatz ermöglicht häufigere Updates der 
Rekonstruktion und trägt zur Immersion bei. Gemessen wurde der Durchsatz auf 
Backend-Seite für jedes Worker-Modell separat.

\paragraph{Ressourcenauslastung}
Die GPU- und CPU-Auslastung wurde kontinuierlich während der Rekonstruktion 
aufgezeichnet. GPU-Utilization und GPU-Memory wurden via \texttt{nvidia-smi} 
erfasst, CPU-Auslastung und RAM-Verbrauch pro Container via Docker Stats. Diese 
Metriken ermöglichen die Bewertung der Ressourceneffizienz und geben Aufschluss 
über Engpässe im System.

\subsubsection{Qualitätsmetriken}

\paragraph{Quantitative Bewertung}
Für Szenen mit verfügbarem Ground-Truth-Mesh wurde der F-Score als kombinierte 
Metrik für Präzision und Recall berechnet:

\begin{align}
    \text{Precision} &= \frac{|\text{TP}|}{|\text{TP}| + |\text{FP}|} \\
    \text{Recall} &= \frac{|\text{TP}|}{|\text{TP}| + |\text{FN}|} \\
    \text{F-Score} &= 2 \cdot \frac{\text{Precision} \cdot \text{Recall}}{\text{Precision} + \text{Recall}}
\end{align}

\noindent
Rekonstruierte Punkte gelten als \textbf{True Positive (TP)}, wenn ihr Abstand zum 
Ground-Truth unter \textit{10} cm liegt, andernfalls als \textbf{False Positive (FP)}. 
\textbf{False Negatives (FN)} sind Ground-Truth-Punkte ohne entsprechenden 
rekonstruierten Punkt innerhalb des Schwellenwerts.

\medskip
\noindent
\textbf{Precision} misst die Genauigkeit der Rekonstruktion, indem sie den Anteil 
korrekt rekonstruierter Punkte angibt. \textbf{Recall} bewertet die 
Vollständigkeit und gibt an, wie viele Ground-Truth-Punkte erfasst wurden. 
Der \textbf{F-Score} kombiniert beide Metriken als harmonisches Mittel und liefert einen 
ausgewogenen Gesamtwert. Je näher der F-Score bei \textit{1.0} liegt, 
desto höher ist die Qualität der Rekonstruktion.

\paragraph{Qualitative Bewertung}
Die rekonstruierten Meshes wurden anhand folgender Kriterien bewertet:

\begin{itemize}
    \item \textbf{Vollständigkeit}: Wie viel Prozent der Szene wurde erfasst?
    \item \textbf{Detailtreue}: Sind feine Strukturen erkennbar?
    \item \textbf{Artefaktfreiheit}: Treten Löcher, Flimmern oder Fehlgeometrie auf?
    \item \textbf{Oberflächenqualität}: Glattheit und Konsistenz der Rekonstruktion
\end{itemize}

\noindent
Die Bewertung erfolgte durch visuelle Inspektion der Rekonstruktionen in Unity 
sowie durch exportierte Screenshots.

\section{Ergebnisse}
\label{sec:ergebnisse}

\subsection{Funktionale Validierung}

Die funktionale Validierung bestätigt, dass RTReconstruct alle definierten Kernfunktionalitäten erfüllt.

\paragraph{End-to-End-Kommunikation}
Die vollständige Kommunikationskette von der Fragmenterfassung im Unity-Client über 
die WebSocket-Verbindung zum Router bis zur Verteilung an die Worker-Container und 
zurück funktioniert stabil. In \textit{15} Testläufen über eine Gesamtdauer von \textit{6} Stunden 
traten \textit{0} Verbindungsabbrüche auf.

\paragraph{Parallele Modellausführung}
Alle vier integrierten Rekonstruktionsmodelle (NeuralRecon, VisFusion, MASt3R-SLAM, 
SLAM3R) konnten gleichzeitig betrieben werden. Die containerisierte Architektur 
ermöglichte eine vollständige Isolierung, sodass unterschiedliche Python- und 
PyTorch-Versionen parallel lauffähig waren. Einzig limitierender Faktor war die einzelne GPU,
die durch die Modelle gemeinsam genutzt wurde.

\paragraph{Multi-Szenen-Unterstützung}
Das System unterstützt die gleichzeitige Verarbeitung mehrerer Szenen. In Tests 
mit \textit{2} parallelen Szenen und \textit{4} verbundenen Clients blieb die Funktionalität 
erhalten. Die szenenspezifische Zuordnung der Rekonstruktionsergebnisse erfolgte 
fehlerfrei.

\paragraph{Visualisierung in VR}
Die über das Backend empfangenen Meshes wurden erfolgreich im Unity-Client 
visualisiert. Das in Kapitel 5 beschriebene Spatial 
Hashing ermöglichte eine performante Darstellung auch bei größeren Meshes und Punktwolken mit bis zu 100.000 Punkten.

\subsection{Performance-Analyse}

\subsubsection{Latenz}

Die Latenz stellt die zentrale Performance-Metrik für die Echtzeitfähigkeit des Systems dar. Im Folgenden wird zunächst die Gesamtlatenz über alle Testszenen und Modelle präsentiert, anschließend in ihre Komponenten zerlegt und abschließend durch die Analyse der Datenvolumina kontextualisiert.

\paragraph{Gesamtlatenz}

Zur Evaluierung der Systemperformance wurde die End-to-End-Latenz \\ \(L_{total}\) als Zeitspanne zwischen dem Absenden eines Fragments vom Client und dem Empfang der zugehörigen Rekonstruktion gemessen. Für jede Kombination aus Testszene und Rekonstruktionsmodell wurden drei unabhängige Testläufe durchgeführt, bei denen identische Eingabedaten verwendet wurden. Um dabei Verzerrungen durch Ressourcenkonflikte zu vermeiden, wurden die Modelle sequenziell im Einzelbetrieb getestet. Abbildung~\ref{fig:latency_boxplots} visualisiert die resultierenden Latenzverteilungen als Boxplots.

\medskip
\noindent
Die Darstellung zeigt auf der x-Achse die vier evaluierten Rekonstruktionsmodelle (NeuralRecon, VisFusion, MASt3R-SLAM, SLAM3R), während die y-Achse die gemessene Latenz in Millisekunden angibt. Pro Modell sind drei Boxplots dargestellt, die jeweils die Latenzverteilung eines Testlaufs repräsentieren. Die farbliche Kodierung kennzeichnet dabei denselben Testlauf über alle Modelle hinweg.

\begin{figure}[H]
    \begin{subfigure}{0.5\textwidth}
        \includegraphics[width=\linewidth]{images/room00_latency.png}
        \caption{Szene V1 -- Geometrische Primitive}
    \end{subfigure}
    \begin{subfigure}{0.5\textwidth}
        \includegraphics[width=\linewidth]{images/room01_latency.png}
        \caption{Szene V2 -- Möbliertes Schlafzimmer}
    \end{subfigure}
    \begin{subfigure}{0.5\textwidth}
        \includegraphics[width=\linewidth]{images/room02_latency.png}
        \caption{Szene V3 -- Komplexer Mehrzweckraum}
    \end{subfigure}
    \begin{subfigure}{0.5\textwidth}
        \includegraphics[width=\linewidth]{images/room00_latency.png}
        \caption{Szene R1 -- Schlafzimmer}
    \end{subfigure}
    \begin{subfigure}{\textwidth}
        \centering
        \includegraphics[width=0.49\linewidth]{images/room00_latency.png}
        \caption{Szene R2 -- Wohnzimmer}
    \end{subfigure}
    \caption{Gesamtlatenz \(L_{total}\) für alle Testszenen und Modelle über drei Testläufe. Die Boxen zeigen den Interquartilbereich (25.\,--\,75.\,Perzentil), die horizontale Linie den Median und die Whiskers den Wertebereich ohne Ausreißer.}
    \label{fig:latency_boxplots}
\end{figure}

\newpage
\noindent
Die Boxplots zeigen für alle Modelle und Szenen geringe Interquartilbereiche und minimale Ausreißer, was auf eine stabile und reproduzierbare Latenzcharakteristik des Systems hinweist. Aufgrund dieser geringen Varianz zwischen den drei Testläufen werden in den folgenden Analysen zur Zusammensetzung der Gesamtlatenz sowie zu Datenvolumina die Messwerte der drei Testläufe aggregiert dargestellt. Dies ermöglicht eine kompaktere Präsentation ohne relevanten Informationsverlust.

\medskip
\noindent
Die Abbildung zeigt deutliche Unterschiede in der Gesamtlatenz zwischen den Testszenen: Szene V1 weist die niedrigsten Latenzwerte auf, während die Latenz in den komplexeren Szenen V3, R1 und R2 ansteigt. Zudem variiert die Latenz zwischen den Modellen, wobei MAST3R durchgängig die höchsten Werte erreicht. Um die Ursachen dieser Variation zu identifizieren, wird die Gesamtlatenz im Folgenden in ihre Komponenten zerlegt.


\paragraph{Zusammensetzung der Gesamtlatenz}

Die beobachteten Latenzunterschiede zwischen den Testszenen lassen sich durch die Zerlegung der Gesamtlatenz in ihre konstituierenden Komponenten \(L_{\text{network}}\), \(L_{\text{inference}}\) und \(L_{\text{render}}\) analysieren. Diese Aufschlüsselung ermöglicht es, szenenabhängige Effekte auf die Inferenzzeit von fixen Overhead-Kosten der Netzwerkkommunikation und Rendering-Pipeline zu separieren. Abbildung~\ref{fig:latency_stacked_bar} visualisiert die resultierende Zusammensetzung für alle Modelle und Testszenen.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{images/latency_split.png}
    \caption{Zusammensetzung der Gesamtlatenz nach Komponenten für alle Rekonstruktionsmodelle, aufgeschlüsselt nach Testszene und gemittelt über die drei Testläufe.}
    \label{fig:latency_stacked_bar}
\end{figure}

\medskip
\noindent
Die Aufschlüsselung zeigt, dass \(L_{\text{inference}}\) den dominierenden Anteil der Gesamtlatenz ausmacht und zwischen den Szenen stark variiert. Der Anteil von \(L_{\text{network}}\) und \(L_{\text{render}}\) bleibt über die Szenen hinweg relativ konstant, nimmt jedoch prozentual mit steigender Szenenkomplexität ab. Die Netzwerklatenz \(L_{\text{network}}\) wird dabei maßgeblich durch die Größe der übertragenen Daten bestimmt, deren Quantifizierung im Folgenden dargestellt wird.


\paragraph{Fragment- und Ergebnisgrößen}

Um die Netzwerklatenz \(L_{\text{network}}\) zu kontextualisieren und die Bandbreitenanforderungen des Systems zu dokumentieren, wurden die durchschnittlichen Fragmentgrößen (Upload) und Ergebnisgrößen (Download) für alle Modelle gemessen. Tabelle~\ref{tab:data_volumes} zeigt die resultierenden Datenvolumina sowie die daraus berechnete genutzte Bandbreite.

\begin{table}[h]
    \centering
    \caption{Durchschnittliche Datenvolumina und genutzte Bandbreite aufgeschlüsselt nach Szene und Modell (gemittelt über drei Testläufe).}
    \label{tab:data_volumes}
    \resizebox{\textwidth}{!}{%
    \begin{tabular}{l|l|c|c|c|c}
        \toprule
        \textbf{Szene} & \textbf{Modell} & \makecell{\textbf{\O~$\text{Frag}_{\text{in}}$~[MB]}} & \makecell{\textbf{\O~$\text{Frag}_{\text{out}}$~[MB]}} & \makecell{\textbf{$\sum\text{Frag}_{\text{in}}$~[MB]}} & \makecell{\textbf{$\sum\text{Frag}_{\text{out}}$~[MB]}} \\
        \midrule
        \multirow{4}{*}{V1} 
            & NeuralRecon  & \multirow{4}{*}{0.82} & 1.83 & \multirow{4}{*}{19.57} & 44.04 \\
            & VisFusion    &                       & 2.73 &                        & 65.40 \\
            & MASt3R-SLAM  &                       & 1.60 &                        & 38.42 \\
            & SLAM3R       &                       & 1.60 &                        & 38.42 \\
        \midrule
        \multirow{4}{*}{V2} 
            & NeuralRecon  & \multirow{4}{*}{1.62} & 2.84 & \multirow{4}{*}{69.57} & 122.28 \\
            & VisFusion    &                      & 3.25  &                        & 139.85 \\
            & MASt3R-SLAM  &                      & 1.60  &                        & 68.60 \\
            & SLAM3R       &                      & 1.60  &                        & 68.84 \\
        \midrule
        \multirow{4}{*}{V3} 
            & NeuralRecon  & \multirow{4}{*}{1.56} & 3.60 & \multirow{4}{*}{88.70} & 204.93 \\
            & VisFusion    &                      & 4.24  &                        & 241.51 \\
            & MASt3R-SLAM  &                      & 1.59  &                        & 90.69 \\
            & SLAM3R       &                      & 1.60  &                        & 91.26 \\
        \midrule
        \multirow{4}{*}{R1} 
            & NeuralRecon  & \multirow{4}{*}{} &  & \multirow{4}{*}{} &  \\
            & VisFusion    &                      &  &                      &  \\
            & MASt3R-SLAM  &                      &  &                      &  \\
            & SLAM3R       &                      &  &                      &  \\
        \midrule
        \multirow{4}{*}{R2} 
            & NeuralRecon  & \multirow{4}{*}{} &  & \multirow{4}{*}{} &  \\
            & VisFusion    &                      &  &                      &  \\
            & MASt3R-SLAM  &                      &  &                      &  \\
            & SLAM3R       &                      &  &                      &  \\
        \bottomrule
    \end{tabular}%
    }
\end{table}


\medskip
\noindent
Die Tabelle zeigt, dass die Fragmentgrößen zwischen den Modellen variieren, wobei SLAM3R aufgrund seiner größeren Fenstergrößen die umfangreichsten Fragmente benötigt. Die Ergebnisgrößen unterscheiden sich ebenfalls deutlich: Volumetrische Verfahren (NeuralRecon, VisFusion) erzeugen größere Meshes im GLB-Format, während punktbasierte Modelle (MASt3R-SLAM, SLAM3R) kompaktere Punktwolken zurückliefern. Die Summe der genutzten Bandbreite liegt bei X.X~Mbps für den Upload und Y.Y~Mbps für den Download.

\medskip
\noindent
Die präsentierten Latenzmessungen bilden zusammen mit den Datenvolumina die Grundlage für die Bewertung der Echtzeitfähigkeit und Skalierbarkeit des Systems in Abschnitt~\ref{sec:diskussion}.

\subsubsection{Durchsatz}

Der Durchsatz ergibt sich für diese Evaluation aus der Anzahl der verarbeiteten Fragmente pro Szene, geteilt durch die mittlere End-To-End Latenz \(L_{total}\) über alle 3 Testläufe. Diese Metrik gibt an, wie viele Fragmente pro Sekunde durch das System verarbeitet werden können und ist ein Indikator für die Aktualisierungsrate der Rekonstruktion im VR-Frontend. Die folgende Tabelle \ref{tab:throughput_results} fasst diese gemessenen Durchsatzwerte für alle Modelle und Szenen zusammen.

\medskip
\begin{table}[h]
    \centering
    \label{tab:throughput_results}
    \begin{tabular}{lccccc}
        \toprule
        \textbf{Modell} & \textbf{V1} & \textbf{V2} & \textbf{V3} & \textbf{R1} & \textbf{R2}\\
        \midrule
        NeuralRecon     & 0.62 & 0.45 & 0.32 &  &  \\
        VisFusion       & 0.38 & 0.35 & 0.30 &  &  \\
        MASt3R-SLAM     & 0.13 & 0.12 & 0.12 &  &  \\
        SLAM3R          & 0.07 & 0.06 & 0.03 &  &  \\
        \bottomrule
    \end{tabular}
    \bigskip
    \caption{Durchsatz nach Modell (Fragmente pro Sekunde)}
\end{table}

\subsubsection{Ressourcenauslastung}

Die Ressourcenauslastung wurde sowohl für das Backend (Server-seitige Rekonstruktion) 
als auch für das Frontend (VR-Client-seitige Visualisierung) getrennt erfasst. Diese 
Trennung ermöglicht die Identifikation von Engpässen in der Pipeline und gibt 
Aufschluss darüber, welche Systemkomponente limitierend wirkt.

\paragraph{Backend-Ressourcen}

Die Backend-Ressourcenauslastung wurde kontinuierlich während der Rekonstruktionsläufe 
auf dem dedizierten Server (AMD Ryzen 9 5900X, NVIDIA GTX 1070 Ti) erfasst. Die 
Messungen umfassen GPU-Auslastung und GPU-Speicherverbrauch (erfasst mittels 
\texttt{nvidia-smi} in 1-Sekunden-Intervallen) sowie CPU- und RAM-Nutzung der 
containerisierten Komponenten (erfasst mittels \texttt{docker stats}).

\medskip
\noindent
\textbf{GPU-Ressourcen:} Tabelle~\ref{tab:gpu_resources} zeigt die durchschnittliche 
GPU-Utilization und den maximalen GPU-Speicherverbrauch während der Rekonstruktion, 
aufgeschlüsselt nach Modell und Testszene.

\begin{table}[h]
    \centering
    \caption{GPU-Auslastung und GPU-Speicherverbrauch während der Rekonstruktion}
    \label{tab:gpu_resources}
    \begin{tabular}{lcccccc}
        \toprule
        \textbf{Modell} & \textbf{Metrik} & \textbf{V1} & \textbf{V2} & \textbf{V3} & \textbf{R1} & \textbf{R2}\\
        \midrule
        \multirow{2}{*}{NeuralRecon} 
            & \O GPU-Utilization [\%] & \textit{44} & \textit{43} & \textit{47} & \textit{} & \textit{} \\
            & Max. VRAM [MB]          & \textit{3825} & \textit{4770} & \textit{7993} & \textit{} & \textit{} \\
        \midrule
        \multirow{2}{*}{VisFusion} 
            & \O GPU-Utilization [\%] & \textit{49} & \textit{53} & \textit{55} & \textit{} & \textit{} \\
            & Max. VRAM [MB]          & \textit{4877} & \textit{4599} & \textit{4418} & \textit{} & \textit{} \\
        \midrule
        \multirow{2}{*}{MASt3R-SLAM} 
            & \O GPU-Utilization [\%] & \textit{100} & \textit{100} & \textit{100} & \textit{} & \textit{} \\
            & Max. VRAM [MB]          & \textit{7969} & \textit{8016} & \textit{7984} & \textit{} & \textit{} \\
        \midrule
        \multirow{2}{*}{SLAM3R} 
            & \O GPU-Utilization [\%] & \textit{98.5} & \textit{99} & \textit{99} & \textit{} & \textit{} \\
            & Max. VRAM [MB]          & \textit{8022} & \textit{7986} & \textit{8012} & \textit{} & \textit{} \\
        \bottomrule
    \end{tabular}
\end{table}

\medskip
\noindent
\textbf{CPU- und RAM-Auslastung:} Die Ressourcennutzung der einzelnen Docker-Container 
ist in Tabelle~\ref{tab:container_resources} dargestellt. Die Werte zeigen die 
durchschnittliche CPU-Last und den RAM-Verbrauch für Router- und Worker-Container, 
gemittelt über alle Testszenen.

\begin{table}[h]
    \centering
    \caption{Durchschnittliche CPU- und RAM-Auslastung der Backend-Container}
    \label{tab:container_resources}
    \begin{tabular}{lcc}
        \toprule
        \textbf{Container} & \textbf{\O CPU-Auslastung [\%]} & \textbf{\O RAM-Verbrauch [MB]} \\
        \midrule
        Router                    & \textit{0.2} & \textit{200} \\
        \midrule
        Worker: NeuralRecon       & \textit{32} & \textit{2780} \\
        Worker: VisFusion         & \textit{17.25} & \textit{3015} \\
        Worker: MASt3R-SLAM       & \textit{14.35} & \textit{3466} \\
        Worker: SLAM3R            & \textit{15.37} & \textit{4070} \\
        \bottomrule
    \end{tabular}
\end{table}

\paragraph{Frontend-Ressourcen}

Die durchschnittliche Frame Rate des Unity-Clients wurde sowohl im Baseline-Betrieb 
(ohne aktive Rekonstruktion) als auch während der Rekonstruktions- und 
Visualisierungsphase gemessen. Tabelle~\ref{frame_rate} zeigt die Ergebnisse.

\begin{figure}[H]
    \centering
    \label{frame_rate}
    % \caption{FPS des Unity-Clients im Baseline-Betrieb und während der Rekonstruktion}
    \includegraphics[width=0.65\textwidth]{images/frontend_fps.png}
\end{figure}

\subsection{Rekonstruktionsqualität}

\subsubsection{Quantitative Bewertung}

Tabelle \ref{tab:fscore_all} zeigt die F-Score-Ergebnisse für alle Szenen mit verfügbarem Ground-Truth für einen Schwellenwert von \textit{10}cm.

\medskip
\noindent
Die dafür benötigten Daten wurden mit der quelloffenen Software CloudCompare gesammelt, indem zunächst die Cloud-to-Cloud Distance-Funktion verwendet wurde, um für jeden Punkt der Rekonstruktion den Abstand zum nächsten Ground-Truth-Punkt zu berechnen. Anschließend wurden die Punkte über \textit{Filter Points by Value} anhand des 10\,cm Schwellenwerts klassifiziert: Abstände \(\leq 10\)\,cm ergeben True Positives, größere Abstände False Positives. False Negatives wurden durch die umgekehrte Distanzberechnung von Ground-Truth zu Rekonstruktion ermittelt, woraus Precision, Recall und F-Score berechnet wurden.


\begin{table}[H]
    \centering
    \label{tab:fscore_all}
    \caption{F-Score-Ergebnisse nach Modell und Szene}
    \begin{tabular}{lccc|ccc|ccc}
        \toprule
        & \multicolumn{3}{c}{\textbf{V1}} & \multicolumn{3}{c}{\textbf{V2}} & \multicolumn{3}{c}{\textbf{V3}} \\
        \cmidrule(lr){2-4} \cmidrule(lr){5-7} \cmidrule(lr){8-10}
        \textbf{Modell} & \textbf{Prec.} & \textbf{Rec.} & \textbf{F-Score} & \textbf{Prec.} & \textbf{Rec.} & \textbf{F-Score} & \textbf{Prec.} & \textbf{Rec.} & \textbf{F-Score} \\
        \midrule
        NeuralRecon     & \textit{0.45} & \textit{0.39} & \textit{0.41} & \textit{0.69} & \textit{0.67} & \textit{0.68} & \textit{0.59} & \textit{0.59} & \textit{0.59} \\
        VisFusion       & \textit{0.57} & \textit{0.52} & \textit{0.54} & \textit{0.57} & \textit{0.65} & \textit{0.61} & \textit{0.57} & \textit{0.68} & \textit{0.62} \\
        SLAM3R          & \textit{0.66} & \textit{0.56} & \textit{0.61} & \textit{0.67} & \textit{0.59} & \textit{0.63} & \textit{0.41} & \textit{0.43} & \textit{0.42} \\
        MASt3R-SLAM     & \textit{0.52} & \textit{0.48} & \textit{0.50} & \textit{0.47} & \textit{0.53} & \textit{0.50} & \textit{0.43} & \textit{0.48} & \textit{0.45} \\
        \bottomrule
    \end{tabular}
\end{table}

\subsubsection{Qualitative Bewertung}

\paragraph{NeuralRecon}
NeuralRecon lieferte robuste Gesamtmodelle mit glatter Oberflächenqualität. Die Rekonstruktionen zeigten eine hohe globale Konsistenz durch die GRU-basierte TSDF-Fusion über mehrere Frames hinweg. Besonders in feature-armen Bereichen wie Wänden (Szene V2, V3) produzierte NeuralRecon saubere, artefaktfreie Oberflächen. Scharfe Kanten (Szene V1) wurden tendenziell durch die volumetrische Glättung abgerundet.

\paragraph{VisFusion}
VisFusion zeigte im direkten Vergleich zu NeuralRecon deutliche Verbesserungen in der Detailtreue. Die visibility-aware Merkmalsfusion ermöglichte eine bessere Handhabung von Okklusionen, was sich besonders in den komplexen Szenen V2 und V3 mit überlagerten Möbeln manifestierte. Die ray-based sparsification führte zu vollständigeren Rekonstruktionen mit erhaltenen feinen Strukturen wie Bilderrahmen und Lampendetails. Wandoberflächen wirkten kohärenter als bei NeuralRecon.

\paragraph{SLAM3R}
SLAM3R zeichnete sich durch sehr dichte Punktwolken aus, die direkt aus dem Image-to-Points-Netzwerk generiert wurden. Die feed-forward-Architektur ermöglichte die höchste Verarbeitungsgeschwindigkeit (20+ FPS). Allerdings war die Vollständigkeit geringer als bei volumetrischen Verfahren – insbesondere in schwer einsehbaren Bereichen wie unter Möbeln entstanden Lücken. Die Local-to-World-Registrierung zeigte in Szene V3 vereinzelt Inkonsistenzen bei der Ausrichtung aufeinanderfolgender Fragmente.

\paragraph{MASt3R-SLAM}
MASt3R-SLAM erzeugte detaillierte, dichte Punktwolken mit hoher lokaler Genauigkeit. Die transformer-basierte Feature-Extraktion ermöglichte robustes Matching auch bei texturarmen Oberflächen. In den realen Szenen R1 und R2 zeigte sich jedoch gelegentlich Drift bei längeren Trajektorien, erkennbar an leichten Verschiebungen zwischen Rekonstruktionsfragmenten verschiedener Zeitpunkte. Die punktbasierte Darstellung erreichte nicht die Oberflächenkohärenz der volumetrischen Verfahren.

\paragraph{Vergleichende Bewertung}
Tabelle \ref{tab:qualitative_comparison} fasst die qualitativen Beobachtungen zusammen und bewertet sie entweder negativ, neutral oder positiv gegnüber den anderen Modellen.

\begin{table}[h]
    \centering
    \label{tab:qualitative_comparison}
    \caption{Qualitative Bewertung der Rekonstruktionsmodelle}
    \begin{tabular}{lcccc}
        \toprule
        \textbf{Kriterium} & \textbf{NeuralRecon} & \textbf{VisFusion} & \textbf{MASt3R} & \textbf{SLAM3R} \\
        \midrule
        Vollständigkeit    & \textit{[+/o/-]} & \textit{[+/o/-]} & \textit{[+/o/-]} & \textit{[+/o/-]} \\
        Detailtreue        & \textit{[+/o/-]} & \textit{[+/o/-]} & \textit{[+/o/-]} & \textit{[+/o/-]} \\
        Artefaktfreiheit   & \textit{[+/o/-]} & \textit{[+/o/-]} & \textit{[+/o/-]} & \textit{[+/o/-]} \\
        Oberflächenqualität & \textit{[+/o/-]} & \textit{[+/o/-]} & \textit{[+/o/-]} & \textit{[+/o/-]} \\
        \bottomrule
    \end{tabular}
    \medskip
\end{table}

\subsection{Modularität und Systemstabilität}

\subsubsection{Integrationsaufwand neuer Modelle}

Um die Modularität der Architektur zu bewerten, wurde ein \textit{[fünftes Modell/Mock-Modell]} 
in das System integriert. Der Integrationsaufwand umfasste:

\begin{itemize}
    \item Erstellung eines Dockerfile: \textit{[X]} Zeilen Code
    \item Implementierung des Worker-Interfaces: \textit{[Y]} Zeilen Code
    \item Anpassung der docker-compose.yml: \textit{[Z]} Zeilen
    \item Gesamtdauer: \textit{[A]} Stunden
\end{itemize}

\noindent
Dies bestätigt, dass die einheitliche Schnittstelle den Integrationsaufwand 
erheblich reduziert.

\subsubsection{Stabilitätstests}

Das System wurde unter folgenden Fehlerszenarien getestet:

\paragraph{Container-Neustart während Rekonstruktion}
Ein Worker-Container wurde manuell gestoppt und nach \textit{[X]} Sekunden neu gestartet. 
Das System erkannte den Ausfall und \textit{[Beschreibung des Verhaltens]}. Die 
Wiederherstellungszeit betrug \textit{[Y]} Sekunden.

\paragraph{Netzwerkunterbrechung}
Die WiFi-Verbindung wurde für \textit{[X]} Sekunden unterbrochen. Das Frontend behielt 
das letzte Mesh \textit{[bei/zeigte Fehlermeldung]}. Nach Wiederherstellung der Verbindung 
konnte die Rekonstruktion \textit{[fortgesetzt/musste neu gestartet]} werden.

\paragraph{Gleichzeitige Last}
Bei parallelem Betrieb von \textit{[X]} Clients und \textit{[Y]} Szenen blieb die Performance 
\textit{[stabil/verschlechterte sich um Z\%]}. Die Latenz stieg auf durchschnittlich \textit{[A]} ms.

\section{Diskussion}
\label{sec:diskussion}

\subsection{Echtzeitfähigkeit}

Die gemessenen Latenzen von \textit{[Bereich]} zeigen, dass der Hauptanteil der Verzögerung 
auf die Modell-Inferenz entfällt (\textit{[X]}\%). Die WebSocket-Kommunikation und 
Container-Architektur verursachen nur einen geringen Overhead von \textit{[Y]}\%. Dies 
bestätigt, dass die gewählte Architektur keine signifikanten Performance-Einbußen 
gegenüber monolithischen Systemen mit sich bringt.

Die Unterschiede zwischen den Modellen lassen sich auf ihre unterschiedlichen 
Rekonstruktionsparadigmen zurückführen: Volumetrische Verfahren wie 
\textit{[NeuralRecon/VisFusion]} erzielen \textit{[schnellere/langsamere]} Inferenzzeiten aufgrund 
\textit{[Begründung: z.B. ihrer TSDF-basierten Fusion]}, während SLAM-basierte Ansätze 
\textit{[Charakteristik: z.B. durch Feature-Matching höhere Latenzen]} aufweisen.

Der gemessene Durchsatz von \textit{[X]} Fragmenten pro Sekunde ermöglicht \textit{[häufige/seltene]} 
Updates der Rekonstruktion. Die Frame Rate im Unity-Client von durchschnittlich 
\textit{[Y]} fps liegt \textit{[im akzeptablen/grenzwertigen]} Bereich für VR-Anwendungen.

\subsection{Modularität der Architektur}

Die erfolgreiche parallele Ausführung aller vier Modelle sowie der geringe 
Integrationsaufwand für neue Modelle (\textit{[X]} Stunden) belegen die hohe Modularität 
des Systems. Die containerisierte Architektur ermöglicht die Isolierung 
unterschiedlicher Laufzeitumgebungen, was die Erweiterbarkeit erheblich vereinfacht.

Die Stabilitätstests zeigen, dass das System \textit{[Szenario A wie Container-Neustarts]} 
robust handhabt. Bei \textit{[Szenario B wie Netzwerkunterbrechungen]} zeigten sich jedoch 
\textit{[Schwächen wie Datenverlust]}, die für produktive Einsätze adressiert werden müssten.

\subsection{Rekonstruktionsqualität im Vergleich}

Der Vergleich der Modelle zeigt erwartungsgemäß unterschiedliche Stärken: 
Volumetrische Verfahren lieferten \textit{[Charakteristik wie robuste Gesamtmodelle mit 
hoher Vollständigkeit]}, während SLAM-basierte Ansätze \textit{[Charakteristik wie feinere 
lokale Details bei geringerer globaler Konsistenz]} aufwiesen. Dies entspricht den 
in Kapitel \textbf{[REF: chap:stand\_der\_technik]} beschriebenen methodischen Unterschieden.

Die quantitativen Ergebnisse zeigen, dass \textit{[Modellname]} mit einem F-Score von \textit{[X]} 
die beste geometrische Genauigkeit erreicht, während \textit{[anderes Modell]} bei \textit{[Kriterium]} 
überzeugt. Die qualitative Bewertung unterstreicht, dass \textit{[Modellname]} für Szenarien 
mit \textit{[Merkmal]} besonders geeignet ist, während \textit{[anderes Modell]} in \textit{[anderen Szenarien]} 
Vorteile bietet.

\subsection{Eignung für VR-Anwendungen}

Die Evaluationsergebnisse zeigen, dass RTReconstruct die definierten funktionalen 
Anforderungen erfüllt und für interaktive VR-Anwendungen \textit{[grundsätzlich geeignet/
mit Einschränkungen nutzbar]} ist. Die Latenzwerte von \textit{[Bereich]} liegen \textit{[im/knapp 
über dem]} für VR akzeptablen Bereich. Die stabile Kommunikation und die erfolgreiche 
Multi-Szenen-Unterstützung bestätigen die Praxistauglichkeit der Architektur für 
das Va.Si.Li-Lab.

Die modulare Struktur ermöglicht es, je nach Anwendungsfall das optimale 
Rekonstruktionsverfahren auszuwählen: \textit{[Szenario A]} profitiert von \textit{[Modellname]}, 
während \textit{[Szenario B]} mit \textit{[anderem Modell]} bessere Ergebnisse erzielt.